#lang racket

(require "mk.rkt")
(require "numbers.rkt")

(defrel (∈ x τ Γ)
  (fresh (xa τa restΓ)
         (conj
          (== `((,xa . ,τa) . ,restΓ) Γ)
          (disj
           (conj (== (unbox xa) x) (== τa τ))
           (conj (=/= xa x) (∈ x τ restΓ))))))

(defrel (not-in-Γo x Γ)
  (disj
   (conj (== '() Γ) succeed)
   (fresh (y τy restΓ)
          (== `((,y . ,τy) . ,restΓ) Γ)
          (=/= y x)
          (not-in-Γo x restΓ))))

; Type inference: for a given expression, guess its type.
(defrel (!- Γ e τ)
  (disj
   (conj (disj (== e '#t) (== e '#f)) (== τ 'Bool))
   (conj (numbero e) (== τ 'Nat))
   (conj (symbolo e) (∈ e τ Γ))
   (fresh (e1)
          (== `(zero? ,e1) e)
          (!- Γ e1 'Nat)
          (not-in-Γo 'zero? Γ)
          (== τ 'Bool))
   (fresh (e1)
          (== `(sub1 ,e1) e)
          (!- Γ e1 'Nat)
          (not-in-Γo 'sub1 Γ)
          (== τ 'Nat))
   (fresh (e1)
          (== `(not ,e1) e)
          (!- Γ e1 'Bool)
          (not-in-Γo 'not Γ)
          (== τ 'Bool))
   (fresh (e1 e2)
          (== `(and ,e1 ,e2) e)
          (!- Γ e1 'Bool)
          (!- Γ e2 'Bool)
          (not-in-Γo 'and Γ)
          (== τ 'Bool))
   (fresh (e1 e2)
          (== `(or ,e1 ,e2) e)
          (!- Γ e1 'Bool)
          (!- Γ e2 'Bool)
          (not-in-Γo 'or Γ)
          (== τ 'Bool))
   (fresh (e1 e2)
          (== `(+ ,e1 ,e2) e)
          (!- Γ e1 'Nat)
          (!- Γ e2 'Nat)
          (not-in-Γo '+ Γ)
          (== τ 'Nat))
   (fresh (cond conseq alt ty)
          (== `(if ,cond ,conseq ,alt) e)
          (!- Γ cond 'Bool)
          (!- Γ conseq ty)
          (!- Γ alt ty)
          (not-in-Γo 'if Γ)
          (== τ ty))
   (fresh (x body arg_ty body_ty)
          (== `(lambda (,x) ,body) e)
          (!- `((,x . ,arg_ty) . ,Γ) body body_ty)
          (== τ `(,arg_ty -> ,body_ty))
          (not-in-Γo 'lambda Γ))
   (fresh (rator rand arg_ty)
          (== `(,rator ,rand) e)
          (!- Γ rator `(,arg_ty -> ,τ))
          (!- Γ rand arg_ty))
   (fresh (fst snd fst_ty snd_ty)
          (== `(cons ,fst ,snd) e)
          (!- Γ fst fst_ty)
          (!- Γ snd snd_ty)
          (not-in-Γo 'cons Γ)
          (== τ `(pairof ,fst_ty ,snd_ty)))
   (fresh (e1 _)
          (== `(car ,e1) e)
          (not-in-Γo 'car Γ)
          (!- Γ e1 `(pairof ,τ ,_)))
   (fresh (e1 _)
          (== `(cdr ,e1) e)
          (not-in-Γo 'cdr Γ)
          (!- Γ e1 `(pairof ,_ ,τ)))
   (fresh (var exp body exp_ty)
          (== `(let ([,var ,exp]) ,body) e)
          (!- Γ exp exp_ty)
          (not-in-Γo 'let Γ)
          (!- `((,var . ,exp_ty) . ,Γ) body τ))
   )
  )

(run*! t (!- '() '((lambda (x) (zero? (cdr x))) (cons #f 0)) t))
; (Bool)
(run*! q
       (!- '() '(let ([f (lambda (x) #t)])
                  (if #t (f (f 5)) (f #t)))
           q))
